package org.example.treecategorybot.bot.entities;

import jakarta.persistence.*;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import java.util.List;

/**
 * Представляет категорию в иерархии категорий.
 *
 * Этот класс является сущностью JPA, которая отображается на таблицу "categories" в базе данных.
 * Каждая категория может иметь уникальное имя, идентификатор и ссылку на родительскую категорию.
 * Также поддерживается связь с дочерними категориями.
 *
 * <p>Класс использует аннотации Lombok для автоматической генерации геттеров, сеттеров и методов
 * {@link Object#equals(Object)} и {@link Object#hashCode()}.</p>
 *
 * @author Сергей Волков
 */
@Entity
@Getter
@Setter
@EqualsAndHashCode
@Table(name = "categories")
public class Category {

    /**
     * Уникальный идентификатор категории.
     *
     * Это поле является первичным ключом сущности и автоматически генерируется
     * при создании новой записи в базе данных с использованием стратегии
     * {@link GenerationType#IDENTITY}. Значение этого поля является уникальным
     * для каждой категории и не может быть {@code null}.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Имя категории.
     *
     * Это поле должно быть уникальным и не может быть пустым.
     * Оно используется для идентификации категории в иерархии.
     * При добавлении новой категории в базу данных,
     * необходимо обеспечить, чтобы имя не дублировалось.
     */
    @Column(nullable = false, unique = true)
    private String name;

    /**
     * Список дочерних категорий.
     *
     * Это поле представляет собой связь "один ко многим" с дочерними категориями.
     * Дочерние категории загружаются лениво ({@link FetchType#LAZY}), что означает,
     * что они будут загружены из базы данных только по мере необходимости.
     *
     * <p>
     * Поле {@code mappedBy} указывает, что это поле связано с полем
     * {@code parent} в дочернем классе {@link Category}.
     *
     * <p>
     * Все операции каскадирования ({@link CascadeType#ALL}) применяются к дочерним
     * категориям, что позволяет автоматически сохранять и обновлять их при
     * изменении родительской категории. Если родительская категория будет
     * удалена, связанные дочерние категории также будут удалены, если они не
     * будут связаны с другими родительскими категориями ({@code orphanRemoval = true}).
     * </p>
     */
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Category> children;

    /**
     * Родительская категория.
     *
     * Это поле представляет собой связь "многие к одному" с родительской категорией.
     * Оно может быть {@code null}, что указывает на отсутствие родительской категории
     * (например, для корневой категории).
     *
     * <p>
     * Поле {@code cascade} устанавливает каскадирование для всех операций
     * ({@link CascadeType#ALL}), что означает, что при сохранении или обновлении
     * дочерней категории также будут автоматически сохранены или обновлены
     * связанные родительские категории.
     * </p>
     *
     * <p>
     * Поле {@code @JoinColumn} указывает, что данное поле связано с колонкой
     * {@code parent_id} в базе данных, которая может содержать {@code null}
     * значения в случае, если категория является корневой.
     * </p>
     */
    @ManyToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "parent_id", nullable = true)
    private Category parent;

    /**
     * Конструктор по умолчанию для класса {@link Category}.
     *
     * Этот конструктор создает новый экземпляр категории без задания
     * каких-либо значений полей. Поля будут инициализированы значениями
     * по умолчанию: идентификатор будет равен {@code null},
     * имя категории будет равно {@code null}, а родительская категория
     * также будет равна {@code null}.
     *
     * Этот конструктор может быть полезен для создания временных объектов
     * категории или при использовании библиотек, которые требуют
     * конструктора без параметров.
     */
    public Category() {}

    /**
     * Конструктор класса {@link Category}, который инициализирует категорию с заданным именем.
     *
     * @param name имя категории. Не должно быть {@code null} или пустым.
     *
     * <p>
     * Этот конструктор создает новый экземпляр категории, устанавливая
     * поле {@code name} на переданное значение. Поля, такие как идентификатор
     * и родительская категория, будут инициализированы значениями по умолчанию
     * (например, {@code null}).
     * </p>
     *
     * <p>
     * Данный конструктор полезен при создании категорий, когда необходимо
     * сразу задать имя, например, при добавлении новой категории в систему.
     * </p>
     *
     * @throws IllegalArgumentException если {@code name} является {@code null}
     * или пустой строкой.
     */
    public Category(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя категории не должно быть null или пустым.");
        }
        this.name = name;
    }

    /**
     * Конструктор класса {@link Category}, который инициализирует категорию с заданным именем и родительской категорией.
     *
     * @param name имя категории. Не должно быть {@code null} или пустым.
     * @param parent родительская категория, или {@code null}, если категория не имеет родителя.
     *
     * <p>
     * Этот конструктор создает новый экземпляр категории, устанавливая
     * поле {@code name} на переданное значение и поле {@code parent} на
     * указанную родительскую категорию. Если {@code parent} равен {@code null},
     * это означает, что категория является корневой.
     * </p>
     *
     * <p>
     * Данный конструктор полезен для создания иерархий категорий,
     * позволяя задавать родительские категории при создании новых категорий.
     * </p>
     *
     * @throws IllegalArgumentException если {@code name} является {@code null}
     * или пустой строкой.
     */
    public Category(String name, Category parent) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя категории не должно быть null или пустым.");
        }
        this.name = name;
        this.parent = parent;
    }

    /**
     * Возвращает строковое представление объекта {@link Category}.
     *
     * <p>
     * Этот метод создает строку, содержащую имя категории, ее идентификатор
     * и информацию о родительской категории. Формат строки будет следующим:
     * <code>Category{name='имя', id=идентификатор, parent=родительская категория}</code>.
     * </p>
     *
     * @return строковое представление объекта {@link Category}.
     */
    @Override
    public String toString() {
        return "Category{" +
                "name='" + name + '\'' +
                ", id=" + id +
                ", parent=" + parent +
                '}';
    }
}
